# Отчет по лабораторной работе 
## по курсу "Искусственый интеллект"

## Нейросетям для распознавания изображений


### Студенты: 

| ФИО       | Роль в проекте                     | Оценка       |
|-----------|------------------------------------|--------------|
| Лукашкин Константин | Значительная |   5    |
| Чекушкин Денис | Значительная |     5     |



## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |    10.6.19          |       5        |

> Некоторые тонкие моменты кода не прокомментированы (отражено в github issues, не требует исправления). Как удалось разбить выборки на обучающую и тестовую при наличии 2 человек в команде?

## Тема работы

Подготовка набора данных и построение нескольких нейросетевых классификаторов для распознавания рукописных символов.
Вариант : (203+215)%5+1=4 - Значки, использующиеся при голосовании: checkmark и крестик
 
## Распределение работы в команде
Лукашкин Константин - Половина датасета + сверточная нейросеть

Чекушкин Денис - Половина датасета + полносвязные нейросети + отчет


## Подготовка данных

Первая часть данных(обработанная). 100 галочек и 100 крестиков:
![1](https://github.com/israelcode/mai_ai_2019/blob/master/lw4/lab-work/xv1.jpg)

Вторая часть данных(обработанная). 100 галочек и 100 крестиков:
![2](https://github.com/israelcode/mai_ai_2019/blob/master/lw4/lab-work/xv2.jpg)


Подготовка датасета заняла довольно большое время. Для начала от руки были написаны все данные(200 символов - галочек и 200 символов - крестиков), поровну на каждого участника группы. Далее фотографии этих данных были обработаны в Microsoft Office Lens в режиме "доска". После это с помощью python и open-cv фотографии были разрезаны на маленькие фрагменты, каждый из которых содержал только один символ. Размер кажого получившегося фрагмента = 95х95. Большой сложности подготовка данных не вызвала. Единственное, что можно отметить - это то, что сначала по невнимательности мы сделали фрагменты разных размеров.

Код:
  
    import cv2
    image = cv2.imread("xv2.jpg") # загружаем изображение и отображаем его
    final_wide = 1525 #  второе фото получилось с бОльшим разрешением, пришлось подгонять его
    r = float(final_wide) / image.shape[1]
    dim = (final_wide, int(image.shape[0] * r))

    resized = cv2.resize(image, dim, interpolation = cv2.INTER_AREA) # уменьшаем изображение до подготовленных размеров
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # делаем серым

    x0=170
    wigth=95
    x1=275

    y0=35
    high=95
    y1=130

    count_w=0
    count_h=0

    i_name=200


    while count_h<15: #15
        print('h=',count_h)
        count_w=0
        x0=180
        x1=275

        while count_w<14:
            print('count_w',count_w)
            cropped = image[y0:y1, x0:x1]
            filename = '{0}.jpg'.format(i_name)
            cv2.imwrite(filename, cropped)
            cv2.imshow("Cropped image", cropped)
            cv2.waitKey(0)
            count_w+=1
            x0+=wigth
            x1+=wigth
            i_name+=1  
        y0+=high
        y1+=high
        count_h+=1


[Ссылка на получившийся датасет](https://github.com/israelcode/mai_ai_2019/tree/master/lw4/lab-work/data)

## Загрузка данных
    DATADIR = "/home/n/data"
    CATEGORIES = ["X", "V"]

    data=[]
    class_list = []


    for category in CATEGORIES:  
        path = os.path.join(DATADIR,category)  
        for img in os.listdir(path): 
            img_array = cv2.imread(os.path.join(path,img) ,cv2.IMREAD_GRAYSCALE) 
            data.append(img_array)
            class_list.append(category)

    num_class_list=[]

    for i in class_list:
        if i=='X':
            num_class_list.append(0)
        if i=='V':
            num_class_list.append(1)

    num_class_arr=np.array(num_class_list)
    data_arr=np.array(data)


## Обучение нейросети
Однослойня полносвязная. Файл : single.py
Фрагмент кода:

    inp = Input(shape=(height * width,)) #input
    out = Dense(num_classes, activation='softmax')(inp) 
    model = Model(input=inp, output=out)
    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) 
    model.fit(X_train, Y_train, batch_size=batch_size, nb_epoch=num_epochs, verbose=1, validation_split=0.1) 
    model.evaluate(X_test, Y_test, verbose=1) 

Многослойная : many.py
Сверточная : snn.py    

### Полносвязная однослойная сеть
Полносвязная — это значит, что каждый нейрон связан со всеми нейронами предыдущего слоя. Подходит для классификации.

**Результаты**

    Epoch 20/20
    320/320 [==============================] - 0s 128us/step - loss: 0.0582 - acc: 0.9212

Точность 92.12%

### Полносвязная многослойная сеть
В многослойных сетях нейроны объединяются в слои. Слой содержит совокупность нейронов с едиными входными сигналами. Число нейронов в каждом слое может быть любым и никак заранее не связано с количеством нейронов в других слоях.

**Результаты**

    Epoch 20/20
    288/288 [==============================] - 1s 2ms/step - loss: 0.0650 - acc: 0.9792

Точность 97.92%
При этом удалось выявить тенденцию, что при разном количестве нейронов получались разные результаты. БОльшему количеству - соответствовала бОльшая точноть. Так же стоить отметить, что полносвязная многослойная оказалась точнее однослойной

### Свёрточная сеть
Содержит один или более объединенных или соединенных сверточных слоев. Использует вариацию многослойного перцептрона, рассмотренного выше. Сверточные слои используют операцию свертки для входных данных и передают результат в следующий слой. Эта операция позволяет сети быть глубже с меньшим количеством параметров.

**Результаты**

    Epoch 20/20
    320/320 [==============================] - 60s 157ms/step - loss: 0.0378 - acc: 0.9958

Точность 99.58%

## Выводы

Лабораторная работа научила нас:
1) Обработке изображению, с помощью open-cv
2) Созданию собственных датастов
3) Обучению нейронных классификаторов

И затавила задуматься над тем, что возможности нейроных сетей очень обширны и их можно применять во многих задачах современной экономики и бизнеса. Нейронные сети это невероятно прорывная технология и возможно она приведет к чему-то большему чем является сейчас. Но уже на данных момент она облегчает и оптимизирует жизнь многих людей(с помощью нейронных сетей некоторые компании рекомендуют товары или разный контент).

Командная работа получилась невероятно эффективной, благодяря возможности взаимодействовать в реальном времени и нахождению в одном месте. Уверен, что если бы мы делали эту лаборатаорную работу удаленно, то ушло бы гораздо больше времени. 
Вклад обоих участников был значительным и практически равным. Более конкретно это было описано в начале отчета.
